//
//  ResultInteractor.swift
//  ifood-mobile-test
//
//  Created by Marcio Garcia on 01/12/18.
//  Copyright (c) 2018 oxltech.com. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol ResultBusinessLogic {
    func analyzeSentiment()
}

protocol ResultDataStore {
    var tweetText: String { get set }
}

class ResultInteractor: ResultBusinessLogic, ResultDataStore {
  
    var presenter: ResultPresentationLogic?
    var worker: ResultWorker?
    var tweetText: String = ""
    
    let operationQueue = OperationQueue()
    var gcKeyOperation: GCApiKeyRequestOperation?
    var gcRequestOperation: BlockOperation?
    
    init(configuration: Configuration) {
        
        let baseUrlString = "\(configuration.value(for: .apiProtocol))://\(configuration.value(for: .baseUrl))"
        let baseUrl = URL(string: baseUrlString)
        
        guard let _baseUrl = baseUrl else {
            return
        }
        
        let restService = AlamofireWrapper(environment: configuration.environment,
                                           baseUrl: _baseUrl.absoluteString,
                                           apiKey: configuration.value(for: .apiKey),
                                           appVersion: configuration.value(for: .appVersion))
        
        let networkService = NetworkService(restService: restService)
        
        let keychain = KeychainWorker(service: configuration.value(for: .bundleId))
        if let key = keychain.get(key: Keys.gcKey.rawValue) {
            self.worker = ResultWorker(dataService: networkService, apiKey: key)
        }
        else {
            let remoteConfig = RemoteConfigWorker()
            gcKeyOperation = GCApiKeyRequestOperation(remoteConfig: remoteConfig)
            gcKeyOperation?.completionBlock = { [weak self] in
                self?.worker = ResultWorker(dataService: networkService, apiKey: (self?.gcKeyOperation?.apiKey)!)
            }
            operationQueue.addOperation(gcKeyOperation!)
        }
    }
    
    // MARK: Do something

    func analyzeSentiment() {
        if self.worker != nil {
            self.requestSentimentAnalysis()
        }
        else {
            gcRequestOperation = BlockOperation { [weak self] in
                self?.requestSentimentAnalysis()
            }
            gcRequestOperation?.addDependency(self.gcKeyOperation!)
            self.operationQueue.addOperation(gcRequestOperation!)
        }
    }
    
    func requestSentimentAnalysis() {
       self.worker?.requestSentimentAnalysis(text: self.tweetText, completion: { [weak self] (analyzedSentiment, error) in
            
            if let _error = error, let message = _error.userInfo["message"] as? String {
                let response = Result.Error.Response(code: _error.code, message: message)
                self?.presenter?.presentError(response: response)
            }
            else {
                guard let sentiment = analyzedSentiment else {
                    let response = Result.Error.Response(code: 999,
                                                         message: NSLocalizedString("Cannot evaluate the tweet's mood", comment: ""))
                    self?.presenter?.presentError(response: response)
                    return
                }
                let response = Result.AnalyzeSentiment.Response(analyzedSentiment: sentiment)
                self?.presenter?.presentSentiment(response: response)
            }
        })
    }
}

class GCApiKeyRequestOperation: AsyncOperation {
    var remoteConfig: RemoteConfigWorker
    var apiKey: String = ""
    
    init(remoteConfig: RemoteConfigWorker) {
        self.remoteConfig = remoteConfig
    }
    
    override func execute() {
        guard self.isCancelled == false else {
            self.finish()
            return
        }
        
        remoteConfig.getString("gc_key") { (value) in
            guard self.isCancelled == false else {
                self.finish()
                return
            }
            
            guard let _key = value else {
                self.finish()
                return
            }

            self.apiKey = _key
            
            let configuration = Configuration()
            let keychain = KeychainWorker(service: configuration.value(for: .bundleId))
            keychain.set(key: Keys.gcKey.rawValue, value: _key)
            
            self.finish()
        }
        
    }
}

